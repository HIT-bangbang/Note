# 一、二进制信号量 Binary Semaphore

**注意** 该功能尽量使用 “直接任务通知” 替代

二进制信号量 Binary Semaphore用于在任务之间进行通知

例如 A正在做一个运算，但是运算的某一步依赖于任务B的结果。当A运算到这一步时需要等待B的通知。B运算结束将结果存入公共内存之后，通过二进制信号量通知A，A从内存中取出更新的数据继续下一步运算。

程序：按下按钮，LED亮起，再按按钮，LED熄灭

```c++
/*
  程序：  Binary Semaphore 是一种信号机制
         一个任务(生产者)发出信号。另外一个任务(消费者)接受信号

  语法：
  SemaphoreHandle_t xHandler; 创建Handler
  xHandler = xSemaphoreCreateBinary(); 创建一个二进制信号量 返回NULL，或者handler
  xSemaphoreGive(xHandler); 生产者+1
  xSemaphoreTake(xHanlder, timeout); 消费者-1 返回pdPASS, 或者pdFAIL

  二进制信号量可以想成就是一个bool类型值为 0 或者 1
  Give就是将信号量置一
  Take就是将信号量-1

  注意：
  Take是阻塞的，如果这个信号量已经是0，就等待一直到timeout
  Give没有超时时间，也不会阻塞，如果信号量已经是1，也不会等待
*/

SemaphoreHandle_t xSemaLED = NULL; //创建信号量Handler

TickType_t timeOut = 1000; //用于获取信号量的Timeout 1000 ticks

void flashLED(void *pvParam) {

  pinMode(23, OUTPUT);
  while (1) {
    //等待按钮按下
    if (xSemaphoreTake( xSemaLED, timeOut) == pdTRUE )
    {
        digitalWrite(23, !digitalRead(23));//反转LED电平
        vTaskDelay(1000);
    }
  }
}

void readBtn(void *pvParam) {

  pinMode(22, INPUT_PULLUP);

  while (1) {
    if (digitalRead(22) == LOW) {
      xSemaphoreGive(xSemaLED); //将信号量置一
      vTaskDelay(120); //button debounce
    }
  }
}

void setup() {
  // put your setup code here, to run once:
  Serial.begin(115200);

  xSemaLED = xSemaphoreCreateBinary(); //创建二进制信号量

  if (xSemaLED == NULL) {
    printf("No Enough Ram, Unable to Create Semaphore.");
  } else {
    xTaskCreate(flashLED,
                "Flash LED",
                1024 * 4,
                NULL,
                1,
                NULL);
    xTaskCreate(readBtn,
                "Read Button",
                1024 * 4,
                NULL,
                1,
                NULL);
  }

}

void loop() {}

```

改进：以上程序中，虽然使用了信号量，可以使flashLED()等待按钮按下的过程进入block状态，不消耗CPU资源，但是readBtn()中仍然是不断地进行digitalRead()，消耗CPU资源。

可以使用中断进行改进：

```c++

/*
  程序：  Binary Semaphore 是一种信号机制 在中断中的用法
         一个任务(生产者)发出信号。另外一个任务(消费者)接受信号
  公众号：孤独的二进制

  语法：
  SemaphoreHandle_t xHandler; 创建Handler
  xHandler = xSemaphoreCreateBinary(); 创建一个二进制信号量 返回NULL，或者handler
  xSemaphoreGive(xHandler); 生产者+1
  xSemaphoreTake(xHanlder, timeout); 消费者-1 返回pdPASS, 或者pdFAIL

  二进制信号量可以想成就是一个整数 0 或者 1
  Give就是+1
  Take就是-1

  Take的时候如果这个整数是0的话，就等待一直到timeout
*/

volatile bool btnPressed = true;
volatile bool btnReleased = false;
volatile int counter = 0;

SemaphoreHandle_t xSemaLED = NULL; //创建信号量Handler
volatile TickType_t btnDeounce = 0; //用于button Debounce

TickType_t timeOut = 1000; //用于获取信号量的Timeout 1000 ticks

void flashLED(void *pvParam) {

  pinMode(23, OUTPUT);
  while (1) {
    if (xSemaphoreTake( xSemaLED, timeOut) == pdTRUE )
    {
      if ((xTaskGetTickCount() - btnDeounce) < 100) { //用于button debounce
        digitalWrite(23, !digitalRead(23));
        vTaskDelay(1000);
      }
    }
  }
}

void readBtn(void *pvParam) {

  pinMode(22, INPUT_PULLUP);

  while (1) {
    if (digitalRead(22) == LOW) {
      xSemaphoreGive(xSemaLED);
    }
  }
}

// 中断函数
void IRAM_ATTR ISR() {
  btnDeounce = xTaskGetTickCountFromISR();  //记录中断发生时的时间
  xSemaphoreGiveFromISR(xSemaLED, NULL);    //二进制量置位
}

void setup() {
  // put your setup code here, to run once:
  Serial.begin(115200);

  xSemaLED = xSemaphoreCreateBinary(); //创建二进制信号量

  if (xSemaLED == NULL) {
    printf("No Enough Ram, Unable to Create Semaphore.");
  } else {
    xTaskCreate(flashLED,
                "Flash LED",
                1024 * 4,
                NULL,
                1,
                NULL);
    // xTaskCreate(readBtn,
    //             "Read Button",
    //             1024 * 4,
    //             NULL,
    //             1,
    //             NULL);
  }

  pinMode(22, INPUT_PULLUP);
  attachInterrupt(22, ISR, FALLING);
}

void loop() {
}

```

# 二、计数信号量 Counting Semaphore
 
从概念上来说，信号量是一个非负整数计数。 信号量通常用来协调对资源的访问，其中信号计数会初始化为可用资源的数目。 然后，线程在资源增加时会增加计数，在删除资源时会减小计数，这些操作都以原子方式执行。

```c++

/*
  程序：  Counting Semaphore 三名顾客abc抢购生产商放出销售的手机
  Counting Semphore时间上是一个内存中的整数，从0 - MAX
  Give +1
  Take -1
*/
SemaphoreHandle_t xSemaPhone = NULL;

String consumerA = "JD";
String consumerB = "TMALL";
String consumerC = "PDD";


void producer(void *paParam) { //制造者 give
  while (1) {

    for (int i = 0; i < random(100, 200); i++) vTaskDelay(10);
    xSemaphoreGive(xSemaPhone);
    Serial.println("...... 手机再放出一台,");
  }
}


void consumer(void *pvParam) { //消费者 take
  String website = *(String *)pvParam;

  while (1) {
    if (xSemaphoreTake(xSemaPhone, portMAX_DELAY) == pdTRUE ) {

      for (int i = 0; i < random(200, 400); i++) vTaskDelay(10);
      Serial.print(website);
      Serial.println("抢到并销售一台: ");

    }
  }
}


void setup() {
  Serial.begin(115200);
  xSemaPhone = xSemaphoreCreateCounting(3, 0);

  xTaskCreate(consumer, "consumer a", 1024 * 6, (void *)&consumerA, 1, NULL);
  xTaskCreate(consumer, "consumer b", 1024 * 6, (void *)&consumerB, 1, NULL);
  xTaskCreate(consumer, "consumer c", 1024 * 6, (void *)&consumerC, 1, NULL);

  xTaskCreate(producer, "producer", 1024 * 6, NULL, 1, NULL);

}
void loop() {
}



```