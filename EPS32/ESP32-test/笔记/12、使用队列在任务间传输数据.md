# 一、使用队列在任务间传输单种数据

## 1.1API

```c++
    //创建队列，uxQueueLength队列长度；uxItemSize每个数据的长度。返回QueueHandle_t类型队列句柄
    QueueHandle_t xQueueCreate( UBaseType_t uxQueueLength,
                             UBaseType_t uxItemSize );

    //xQueue句柄；pvItemToQueue入队列的数据，xTicksToWait 等待超时时间。返回值pdPASS或者pdFALSE
    BaseType_t xQueueSend(
                            QueueHandle_t xQueue,
                            const void * pvItemToQueue,
                            TickType_t xTicksToWait
                         );
    //xQueue句柄；pvItemToQueue用于接收出队列数据的指针，xTicksToWait 等待超时时间;返回值pdPASS或者pdFALSE
    BaseType_t xQueueReceive(
                               QueueHandle_t xQueue,
                               void *pvBuffer,
                               TickType_t xTicksToWait
                            );
```


## 1.2 队列满或空时的两种策略

### 1.2.1队列满时，入队列操作两种策略
1、无限期等待
2、等待一段时间后丢弃数据，放弃此次入队列

### 1.2.2队列空时，出队列的两种策略
1、无限期等待，直到队列种有数据
2、等待一段时间放弃此次出队列

## 1.3注意：任务等待队列时，该任务被阻塞在这里

一个队列可以有多个写入数据的任务和多个读取数据的任务。

当一个任务试图从队列读取数据的时候，它可以设置一个阻塞时间（block time）。

这是当队列数据为空时，任务处于  **阻塞状态**  的时间。

当有数据在队列或者到达阻塞时间的时候，任务都会进入就绪状态。

如果有多个任务同时在阻塞状态等待队列数据，优先级高的任务会在数据到达时进入就绪状态；

在优先级相同的时候，等待时间长的任务会进入就绪状态。

同理可以推及多个任务写入数据时候的运行状态。


```c++
/*
   程序：  消息队列
   公众号：孤独的二进制
   仿真程序：https://wokwi.com/projects/332949416352678483

   API：
    QueueHandle_t xQueueCreate( UBaseType_t uxQueueLength,
                             UBaseType_t uxItemSize );

    BaseType_t xQueueSend(
                            QueueHandle_t xQueue,
                            const void * pvItemToQueue,
                            TickType_t xTicksToWait
                         );
    BaseType_t xQueueReceive(
                               QueueHandle_t xQueue,
                               void *pvBuffer,
                               TickType_t xTicksToWait
                            );

*/
#include <LiquidCrystal_I2C.h>
LiquidCrystal_I2C lcd(0x27, 20, 4);

QueueHandle_t queueMsg = xQueueCreate(8, sizeof(char[20]));

//返回随机的文字
String randomMsg() {
  String myStrings[] = {
    "Nice to meet you",
    "Where are U from?",
    "What do you do?",
    "What do U like?",
    "What is UR num?",
    "Do U have FB?",
    "Thanks so much.",
    "I am Chinese.",
    "I do not KNOW.",
    "Thank you.",
    "That helps.",
    "I Love U",
    "Do U miss me?",
    "Be careful.",
    "Don't worry.",
    "Good idea.",
    "He's right.",
    "I ate already.",
    "More than that.",
    "Nothing else.",
    "See you later.",
    "Take it outside.",
  };
  return myStrings[random(0, 22)];
}

void userA(void *ptParam) {
  char msg[20];
  String userID = "A: ";

  while (1) {
    (userID  + randomMsg()).toCharArray(msg, 20);

    TickType_t timeOut = portMAX_DELAY;
    //TickType_t timeOut = 10;
    if (xQueueSend(queueMsg, &msg, timeOut) != pdPASS)  {
      Serial.print(userID);
      Serial.println("Queue is full.");
    };

    vTaskDelay(2000);
  }
}

void userB(void *ptParam) {
  char msg[20];
  String userID = "B: ";

  while (1) {
    (userID  + randomMsg()).toCharArray(msg, 20);

    //portMAX_DELAY - 无限Block
    TickType_t timeOut = portMAX_DELAY;
    //TickType_t timeOut = 10;
    if (xQueueSend(queueMsg, &msg, timeOut) != pdPASS)  {
      Serial.print(userID);
      Serial.println("Queue is full.");
    };

    vTaskDelay(2000);
  }
}

void userC(void *ptParam) {
  char msg[20];
  String userID = "C: ";

  while (1) {
    (userID  + randomMsg()).toCharArray(msg, 20);

    //portMAX_DELAY - 无限Block
    TickType_t timeOut = portMAX_DELAY;
    //TickType_t timeOut = 10;
    if (xQueueSend(queueMsg, &msg, timeOut) != pdPASS)  {
      Serial.print(userID);
      Serial.println("Queue is full.");
    };

    vTaskDelay(2000);
  }
}

void lcdTask(void *ptParam) {  //LCD任务主体

  lcd.init();
  lcd.backlight();

  char line0[20] = {' '};
  char line1[20] = {' '};
  char line2[20] = {' '};
  char line3[20] = {' '};
  char * lines[] = { line0, line1, line2, line3 };

  while (1) {
    //文字向上滚动
    strcpy(line0, line1);
    strcpy(line1, line2);
    strcpy(line2, line3);

    //TickType_t timeOut = portMAX_DELAY; //超时时间为无限长，尽量不要这样用
    TickType_t timeOut = 10;
    //从队列中获取一个数据
    if (xQueueReceive(queueMsg, lines[3], timeOut) == pdPASS) {
      //显示所有的4行文字
      for (int i = 3; i >= 0; i--) {
        lcd.setCursor(0, i);
        lcd.print("                    "); //clear this line
        lcd.setCursor(0, i);
        lcd.print(lines[i]);
      }
    }  else {
      Serial.println("Message Queue is Empty");
    };

    vTaskDelay(10);
  }
}

void setup()
{
  Serial.begin(115200);

  xTaskCreate(userA, "User A", 1024 * 8, NULL, 1, NULL);
  xTaskCreate(userB, "User B", 1024 * 8, NULL, 1, NULL);
  xTaskCreate(userC, "User C", 1024 * 8, NULL, 1, NULL);

  xTaskCreate(lcdTask, "lcd", 1024 * 8, NULL, 1, NULL);
}

void loop() {}
```

# 二、使用队列在任务之间传输多种数据

## 2.1原理

队列只是一块给定大小的内存。创建队列时只需要给定uxQueueLength队列长度和uxItemSize每个数据的长度，它并不关心存储的每个数据类型。

所以可以使队列的每个元素都是一个结构体，达到使用队列存储不同类型数据的目的

以下程序演示同时接收DHT22和LDR的两种数据，并显示在LCD屏幕上
```c++
#include "DHTesp.h"
#include <LiquidCrystal_I2C.h>
LiquidCrystal_I2C lcd(0x27, 20, 4);

#define DHT22_ID 0
#define LDR_ID 1

//数据结构体
typedef struct {
  byte deviceID;
  float value1;
  float value2;
} SENSOR;

//创建队列，并返回句柄。使用sizeof自动计算结构体的大小
QueueHandle_t queueSensor = xQueueCreate(8, sizeof(SENSOR));

void dht22(void *ptParam) {

  const byte dhtPin = 32;
  DHTesp dhtSensor;
  dhtSensor.setup(dhtPin, DHTesp::DHT22);

  SENSOR dht22Sensor;
  dht22Sensor.deviceID = DHT22_ID;

  while (1 ) {
    TempAndHumidity  data = dhtSensor.getTempAndHumidity();

    // Serial.println("Temp: " + String(data.temperature, 2) + "°C");
    // Serial.println("Humidity: " + String(data.humidity, 1) + "%");

    dht22Sensor.value1 = data.temperature;
    dht22Sensor.value2 = data.humidity;

    // TickType_t timeOut = portMAX_DELAY;
    TickType_t timeOut = 2000;
    //向队列中塞进去结构体
    if (xQueueSend(queueSensor, &dht22Sensor, timeOut) != pdPASS) {
      Serial.println("DHT22: Queue is full.");
    }

    vTaskDelay(1000);
  }

}

void ldr(void *ptParam) {
  const float GAMMA = 0.7;
  const float RL10 = 50;
  const byte ldrPIN = 27;
  pinMode(ldrPIN, INPUT);

  SENSOR ldrSensor;
  ldrSensor.deviceID = LDR_ID;

  while (1 ) {
    int analogValue = analogRead(ldrPIN);

    float voltage = analogValue / 4095. * 5;
    float resistance = 2000 * voltage / (1 - voltage / 5);
    float lux = pow(RL10 * 1e3 * pow(10, GAMMA) / resistance, (1 / GAMMA));

    // Serial.print("LDR Light Sensor lux : ");
    // Serial.println(lux);

    ldrSensor.value1 = lux;
    ldrSensor.value2 = 0.0;

    // TickType_t timeOut = portMAX_DELAY;
    TickType_t timeOut = 2000;
    if (xQueueSend(queueSensor, &ldrSensor, timeOut) != pdPASS) {
      Serial.println("LDR: Queue is full.");
    }

    vTaskDelay(1000);
  }

}

void lcdTask(void *ptParam) {  //LCD任务主体

  lcd.init();
  lcd.backlight();

  lcd.setCursor(0, 0);
  lcd.print("   LONELY  BINARY  ");

  SENSOR data;
  while (1) {
    //TickType_t timeOut = portMAX_DELAY;
    TickType_t timeOut = 2000;
    if (xQueueReceive(queueSensor, &data, timeOut) == pdPASS) {

      switch (data.deviceID) {
        case DHT22_ID:
          lcd.setCursor(0, 1);
          lcd.print("Temp: " + String(data.value1, 2) + "c");
          lcd.setCursor(0, 2);
          lcd.print("Humidity: " + String(data.value2, 1) + "%");
          break;
        case LDR_ID:
          lcd.setCursor(0, 3);
          if (data.value1 > 50) {
            lcd.print("Bright ");
          } else {
            lcd.print("Dark ");
          }
          //lcd.setCursor(0, 3);
          lcd.print(String(data.value1, 2) + " lux");
          break;
        default:
          Serial.println("LCD: Unkown Device");
          break;
      }
    }  else {
      Serial.println("LCD: Message Queue is Empty");
    };

    vTaskDelay(2000);
  }
}

void setup()
{
  Serial.begin(115200);

  xTaskCreate(dht22, "DHT22", 1024 * 4, NULL, 1, NULL);
  xTaskCreate(ldr, "LDR LIGHT", 1024 * 4, NULL, 1, NULL);
  xTaskCreate(lcdTask, "lcd", 1024 * 8, NULL, 1, NULL);

}


void loop() {}

```