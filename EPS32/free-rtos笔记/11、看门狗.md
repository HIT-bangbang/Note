# 看门狗

ESP32有两个核心，每个核心均有一个看门狗。

每个核心均会执行一个IDLE任务，等级为0，当任务被删除时，该任务负责回收释放被删除任务的内存。

在核心1上运行loopback任务，等级为1。

缺省情况下，核心0的IDLE任务开启了看门狗，如果IDLE任务5s没有喂狗，将会触发重启。

如果有在核心0上的某个任务一直占用资源，使得IDLE无法运行不能喂狗，将会触发重启，而在核心1上有任务占用整个核心的资源则不会，因为核心1上的IDLE并没有开启看门狗


## 程序1在核心0上面运行永不停息的任务导致重启
```c++
#include <arduino.h>
/*
   WOKWI模拟器没有看门狗，请大家放到真实ESP32上
   程序： 看门狗 WatchDog
   公众号：孤独的二进制

   说明：看门狗是针对Task任务的
        Arduion-ESP32 默认在 Core 0 的 IDLE 任务开启了看门狗 时间为 5000 ticks = 5秒
        Core 0 和 Core 1 都运行了 FreeRTOS的IDLE任务，优先级为 0
                         IDLE任务是用于清理被删除任务的内存
        Core 1 loopBack任务就是Arduino的 setup 和 loop 优先级为 1

   待解决：程序中如何看所有开启看门狗的任务

*/
#include "esp_task_wdt.h" //Used by esp_task_wdt_reset()

#define CORE_ZERO 0
#define CORE_ONE 1

//feedTheDogInAllTasks()
//通过寄存器给所有任务的狗喂时
#include "soc/timer_group_struct.h"
#include "soc/timer_group_reg.h"

void feedTheDogInAllTasks() { //通过寄存器给所有任务的狗喂时
  // feed dog 0
  TIMERG0.wdt_wprotect = TIMG_WDT_WKEY_VALUE; // write enable
  TIMERG0.wdt_feed = 1;                     // feed dog
  TIMERG0.wdt_wprotect = 0;                 // write protect
  // feed dog 1
  TIMERG1.wdt_wprotect = TIMG_WDT_WKEY_VALUE; // write enable
  TIMERG1.wdt_feed = 1;                     // feed dog
  TIMERG1.wdt_wprotect = 0;                 // write protect
}

// 永远不休息的task
void taskWithoutBreak(void * ptParam) {
  while (1) {
    //vTaskDelay(1); //让Task进入Block状态，退让资源
    //vTaskSuspend(NULL); //让Task进入Suspend状态，退让资源
  }
}

/*
   Demo 1:
   Core 0 上有两个任务分别是: IDLE(0),  taskWithoutBreak(1)
   因为taskWithoutBreak优先级高，而且永远不会退让出资源，所以IDLE(0)永远不会运行
   Core 0 IDLE(0) 在Arduino-ESP32上默认开启了 Watch Dog， 时间是5秒
   因为IDLE(0)无法运行，所以不能喂狗，导致5秒后重启，内容如下

  E (10156) task_wdt: Task watchdog got triggered. The following tasks did not reset the watchdog in time:
  E (10156) task_wdt:  - IDLE (CPU 0)
  E (10156) task_wdt: Tasks currently running:
  E (10156) task_wdt: CPU 0: TASK-NO-BREAK
  E (10156) task_wdt: CPU 1: loopTask
  E (10156) task_wdt: Aborting.
*/
void demo1() {
  xTaskCreatePinnedToCore(taskWithoutBreak, "TASK-NO-BREAK", 1024, NULL, 1, NULL, CORE_ZERO);
}

/*
   Demo 2:
   Core 1 上有两个任务分别是: IDLE(0),  loopBack(1), taskWithoutBreak(2)
   因为taskWithoutBreak优先级高，而且永远不会退让出资源，所以IDLE(0)和loopBack(1)永远不会运行
   Core 1 IDLE(1) 在Arduino-ESP32上默认没有开启了 Watch Dog， 所以不会自动重启
*/
void demo2() {
  xTaskCreatePinnedToCore(taskWithoutBreak, "TASK-NO-BREAK", 1024, NULL, 2, NULL, CORE_ONE);
}

void setup() {
  // put your setup code here, to run once:
  Serial.begin(115200);

  //手动关闭CPU上的TWDT - 慎重操作
  //  disableCore0WDT();
  //  disableCore1WDT();

  //给本任务添加看门狗（NULL代表本任务）
  //这个命令需要放在demo2()的前面，否则连运行的机会都没有
  //esp_task_wdt_add(NULL);

  //移除本任务的看门狗（NULL代表本任务）
  //esp_task_wdt_delete(NULL)

  demo1(); //核心0
  //demo2(); //核心1

}

void loop() {
  // esp_task_wdt_reset(); //给自己任务的狗喂时间
  // feedTheDogInAllTasks(); //通过寄存器给所有任务的狗喂时间

  Serial.println("loopBack Task - Priority 1");
  vTaskDelay(100);
}

```
loop中打印信息，5s后系统重启，并输出信息：

    E (10113) task_wdt: Task watchdog got triggered. The following tasks did not reset the watchdog in time:
    E (10113) task_wdt:  - IDLE (CPU 0)
    E (10113) task_wdt: Tasks currently running:
    E (10113) task_wdt: CPU 0: TASK-NO-BREAK
    E (10113) task_wdt: CPU 1: IDLE
    E (10113) task_wdt: Aborting.

    abort() was called at PC 0x400d8375 on core 0

## 程序2在核心1上面运行永不停息的任务不会导致重启
```c++
#include <arduino.h>
/*
   WOKWI模拟器没有看门狗，请大家放到真实ESP32上
   程序： 看门狗 WatchDog
   公众号：孤独的二进制

   说明：看门狗是针对Task任务的
        Arduion-ESP32 默认在 Core 0 的 IDLE 任务开启了看门狗 时间为 5000 ticks = 5秒
        Core 0 和 Core 1 都运行了 FreeRTOS的IDLE任务，优先级为 0
                         IDLE任务是用于清理被删除任务的内存
        Core 1 loopBack任务就是Arduino的 setup 和 loop 优先级为 1

   待解决：程序中如何看所有开启看门狗的任务

*/
#include "esp_task_wdt.h" //Used by esp_task_wdt_reset()

#define CORE_ZERO 0
#define CORE_ONE 1

#include "soc/timer_group_struct.h"
#include "soc/timer_group_reg.h"

// 永远不休息的task
void taskWithoutBreak(void * ptParam) {
  while (1) {
    //vTaskDelay(1); //让Task进入Block状态，退让资源
    //vTaskSuspend(NULL); //让Task进入Suspend状态，退让资源
  }
}

/*
   Demo 2:
   Core 1 上有两个任务分别是: IDLE(0),  loopBack(1), taskWithoutBreak(2)
   因为taskWithoutBreak优先级高，而且永远不会退让出资源，所以IDLE(0)和loopBack(1)永远不会运行
   Core 1 IDLE(1) 在Arduino-ESP32上默认没有开启了 Watch Dog， 所以不会自动重启
*/
void demo2() {
  xTaskCreatePinnedToCore(taskWithoutBreak, "TASK-NO-BREAK", 1024, NULL, 2, NULL, CORE_ONE);
}

void setup() {
  Serial.begin(115200);
  demo2(); //核心1
}

void loop() {
  Serial.println("loopBack Task - Priority 1");
  vTaskDelay(100);
}

```

但是会导致核心1死机，因为任务一直占用资源不释放

## 为loopback()添加看门狗

```c++
#include <Arduino.h>
#include "esp_task_wdt.h" //Used by esp_task_wdt_reset()

#define CORE_ZERO 0
#define CORE_ONE 1

//feedTheDogInAllTasks()
//通过寄存器给所有任务的狗喂时
#include "soc/timer_group_struct.h"
#include "soc/timer_group_reg.h"

void feedTheDogInAllTasks() { //通过寄存器给所有任务的狗喂时
  // feed dog 0
  TIMERG0.wdt_wprotect = TIMG_WDT_WKEY_VALUE; // write enable
  TIMERG0.wdt_feed = 1;                     // feed dog
  TIMERG0.wdt_wprotect = 0;                 // write protect
  // feed dog 1
  TIMERG1.wdt_wprotect = TIMG_WDT_WKEY_VALUE; // write enable
  TIMERG1.wdt_feed = 1;                     // feed dog
  TIMERG1.wdt_wprotect = 0;                 // write protect
}

// 永远不休息的task
void taskWithoutBreak(void * ptParam) {
  while (1) {
    //vTaskDelay(1); //让Task进入Block状态，退让资源
    //vTaskSuspend(NULL); //让Task进入Suspend状态，退让资源
  }
}

/*
   Demo 2:
   Core 1 上有两个任务分别是: IDLE(0),  loopBack(1), taskWithoutBreak(2)
   因为taskWithoutBreak优先级高，而且永远不会退让出资源，所以IDLE(0)和loopBack(1)永远不会运行
   Core 1 IDLE(1) 在Arduino-ESP32上默认没有开启了 Watch Dog， 所以不会自动重启
*/
void demo2() {
  xTaskCreatePinnedToCore(taskWithoutBreak, "TASK-NO-BREAK", 1024, NULL, 2, NULL, CORE_ONE);
}

void setup() {
  // put your setup code here, to run once:
  Serial.begin(115200);

  //手动关闭CPU上的TWDT - 慎重操作
  //  disableCore0WDT();
  //  disableCore1WDT();

  //给本任务添加看门狗（NULL代表本任务）
  //这个命令需要放在demo2()的前面，否则连运行的机会都没有
  esp_task_wdt_add(NULL);

  //移除本任务的看门狗（NULL代表本任务）
  //esp_task_wdt_delete(NULL)

  demo2(); //核心1

}

void loop() {
  esp_task_wdt_reset(); //给自己任务的狗喂时间
  // feedTheDogInAllTasks(); //通过寄存器给所有任务的狗喂时间

  Serial.println("loopBack Task - Priority 1");
  vTaskDelay(100);
}
```

每5s输出以下内容：

    E (10115) task_wdt: Task watchdog got triggered. The following tasks did not reset the watchdog in time:
    E (10115) task_wdt:  - loopTask (CPU 1)
    E (10115) task_wdt: Tasks currently running:
    E (10115) task_wdt: CPU 0: IDLE
    E (10115) task_wdt: CPU 1: TASK-NO-BREAK
    E (10115) task_wdt: Aborting.

## 释放资源的两种方法：vTaskDelay()和vTaskSuspend()

```c++
/*
   WOKWI模拟器没有看门狗，请大家放到真实ESP32上
   程序： 看门狗 WatchDog
   公众号：孤独的二进制

   说明：看门狗是针对Task任务的
        Arduion-ESP32 默认在 Core 0 的 IDLE 任务开启了看门狗 时间为 5000 ticks = 5秒
        Core 0 和 Core 1 都运行了 FreeRTOS的IDLE任务，优先级为 0
                         IDLE任务是用于清理被删除任务的内存
        Core 1 loopBack任务就是Arduino的 setup 和 loop 优先级为 1

   待解决：程序中如何看所有开启看门狗的任务

*/
#include "esp_task_wdt.h" //Used by esp_task_wdt_reset()

#define CORE_ZERO 0
#define CORE_ONE 1

//feedTheDogInAllTasks()
//通过寄存器给所有任务的狗喂食
#include "soc/timer_group_struct.h"
#include "soc/timer_group_reg.h"

// 永远不休息的task
void taskWithoutBreak(void * ptParam) {
  while (1) {
    vTaskDelay(1); //让Task进入Block状态，退让资源
    //vTaskSuspend(NULL); //让Task进入Suspend状态，退让资源
  }
}

void demo2() {
  xTaskCreatePinnedToCore(taskWithoutBreak, "TASK-NO-BREAK", 1024, NULL, 2, NULL, CORE_ONE);
}

void setup() {
  // put your setup code here, to run once:
  Serial.begin(115200);

  //给本任务添加看门狗（NULL代表本任务）
  //这个命令需要放在demo2()的前面，否则连运行的机会都没有
  esp_task_wdt_add(NULL);

  //移除本任务的看门狗（NULL代表本任务）
  //esp_task_wdt_delete(NULL)

  demo2(); //核心1

}

void loop() {
  esp_task_wdt_reset(); //给自己任务的狗喂时间
  // feedTheDogInAllTasks(); //通过寄存器给所有任务的狗喂时间

  Serial.println("loopBack Task - Priority 1");
  vTaskDelay(100);
}

```

注意我们在taskWithoutBreak任务中释放了1个tick时间的资源给loopback任务（优先级为1），

但是更低优先级的IDLE任务（优先级为0）仍然无法获得资源。

在实际开发过程中，也要注意这一点，考虑周全，为所有任务都留出资源

## 手动关闭核心上的看门狗

    //手动关闭CPU核心上的TWDT - 慎重操作
    disableCore0WDT();
    disableCore1WDT();

## 移除某个任务的看门狗

    esp_task_wdt_delete(NULL)//传入参数为句柄，NULL表示语句所在的当前任务

## 通过寄存器为所有看门狗喂食 (完整代码)

# 完整代码

```c++

/*
   WOKWI模拟器没有看门狗，请大家放到真实ESP32上
   程序： 看门狗 WatchDog
   公众号：孤独的二进制

   说明：看门狗是针对Task任务的
        Arduion-ESP32 默认在 Core 0 的 IDLE 任务开启了看门狗 时间为 5000 ticks = 5秒
        Core 0 和 Core 1 都运行了 FreeRTOS的IDLE任务，优先级为 0
                         IDLE任务是用于清理被删除任务的内存
        Core 1 loopBack任务就是Arduino的 setup 和 loop 优先级为 1

   待解决：程序中如何看所有开启看门狗的任务

*/
#include "esp_task_wdt.h" //Used by esp_task_wdt_reset()

#define CORE_ZERO 0
#define CORE_ONE 1

//feedTheDogInAllTasks()
//通过寄存器给所有任务的狗喂时
#include "soc/timer_group_struct.h"
#include "soc/timer_group_reg.h"
void feedTheDogInAllTasks() { //通过寄存器给所有任务的狗喂时
  // feed dog 0
  TIMERG0.wdt_wprotect = TIMG_WDT_WKEY_VALUE; // write enable
  TIMERG0.wdt_feed = 1;                     // feed dog
  TIMERG0.wdt_wprotect = 0;                 // write protect
  // feed dog 1
  TIMERG1.wdt_wprotect = TIMG_WDT_WKEY_VALUE; // write enable
  TIMERG1.wdt_feed = 1;                     // feed dog
  TIMERG1.wdt_wprotect = 0;                 // write protect
}


// 永远不休息的task
void taskWithoutBreak(void * ptParam) {
  while (1) {
    //vTaskDelay(1); //让Task进入Block状态，退让资源
    //vTaskSuspend(NULL); //让Task进入Suspend状态，退让资源
  }
}

void setup() {
  // put your setup code here, to run once:
  Serial.begin(115200);

  //手动关闭CPU上的TWDT - 慎重操作
  //  disableCore0WDT();
  //  disableCore1WDT();

  //给本任务添加看门狗（NULL代表本任务）
  //这个命令需要放在demo2()的前面，否则连运行的机会都没有
  esp_task_wdt_add(NULL);

  //移除本任务的看门狗（NULL代表本任务）
  //esp_task_wdt_delete(NULL)

  demo1(); //核心0
  //demo2(); //核心1

}

void loop() {
  // esp_task_wdt_reset(); //给自己任务的狗喂时间
  // feedTheDogInAllTasks(); //通过寄存器给所有任务的狗喂时间

  Serial.println("loopBack Task - Priority 1");
  vTaskDelay(100);
}

/*
   Demo 1:
   Core 0 上有两个任务分别是: IDLE(0),  taskWithoutBreak(1)
   因为taskWithoutBreak优先级高，而且永远不会退让出资源，所以IDLE(0)永远不会运行
   Core 0 IDLE(0) 在Arduino-ESP32上默认开启了 Watch Dog， 时间是5秒
   因为IDLE(0)无法运行，所以不能喂狗，导致5秒后重启，内容如下

  E (10156) task_wdt: Task watchdog got triggered. The following tasks did not reset the watchdog in time:
  E (10156) task_wdt:  - IDLE (CPU 0)
  E (10156) task_wdt: Tasks currently running:
  E (10156) task_wdt: CPU 0: TASK-NO-BREAK
  E (10156) task_wdt: CPU 1: loopTask
  E (10156) task_wdt: Aborting.
*/
void demo1() {
  xTaskCreatePinnedToCore(taskWithoutBreak, "TASK-NO-BREAK", 1024, NULL, 1, NULL, CORE_ZERO);
}

/*
   Demo 2:
   Core 1 上有两个任务分别是: IDLE(0),  loopBack(1), taskWithoutBreak(2)
   因为taskWithoutBreak优先级高，而且永远不会退让出资源，所以IDLE(0)和loopBack(1)永远不会运行
   Core 1 IDLE(1) 在Arduino-ESP32上默认没有开启了 Watch Dog， 所以不会自动重启
*/
void demo2() {
  xTaskCreatePinnedToCore(taskWithoutBreak, "TASK-NO-BREAK", 1024, NULL, 2, NULL, CORE_ONE);
}

```